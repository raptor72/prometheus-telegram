# prometheus-telegram

**prometheus-telegram** - бот для расширения возможностей системы Prometheus по оповещению пользователей о наступлении аварийных событий.

Бот выполняет две задачи:

1. Присылает оповещения об аварийных сообщениях из Prometheus пользователям в Telegram. 

2. Так как зачастую в качестве дашборда к Prometheus настраивается Grafana, 
бот дает возможность пользователю загружать скриншоты конкретных графиков из Grafana. 
Это позволяет удаленно получить визуализацию интересующих метрик.

Решение состоит из двух основных компонентов. 
 - Скрипта **bot.py** в котором описан класс Bot, отвечающий главным образом за взаимодействие с Telegram.
 - Точка входа программы - скрипт **main.py** запускающий сервер.

Помимо этого в проекте присутствует: 

 - конфигурационный файл - **exhample_config**
 - файл в котором храняться подписки пользователей на алармы - **users**
 - набор юнит-тестов **test_prometheus_telegram.py**
 - список зависимостей **requirements.txt**
 - файл для сборки докер-контейнера - **Dockerfile**

В main.py __main__ на входе принимаются 4 аргумента:

 - порт'-p', '--port'  по умолчанию 8080)
 - хост '-H', '--host', по умолчанию  '127.0.0.1')
 - путь до конфигурационного файла '-c', '--config', по умолчанию =DEFAULT_CONFIG)
 - путь до лог-файла '-l', '--log', по умолчанию None)

Наиболее интересен конфиг. Его проверяет функция check_config если файл будет составлен не верно 
функция вернет False и скрипт не запустится. Об этом будет сгенерировано соответствующее аварийное сообщение.
Если с конфигом все впорядке то запускается функция run.
При запуске данная функция создает обьект хранилище для алармов all_alarms, загружает конфиг-файл, создает служебную переменную users_reload_time, загружает список пользователей и их подписка на алармы функцией load_users() и инициализирует экземпляр класса Bot. 

После функция связывает адрес и порт и начинает слушать буфер.
Далее методом os.fork() порождается дочерний процесс в котором запускается метод общения бота с телеграм bot.polling()
Этот метод состоит в периодической отправке запросов get_updates на сервера телеграм. В случае наличия обновления Telegram возвращает
ответ ответ с json,  который будет обрабатываться ботом.

В родительком процессе запускается чтение буфера функцией read_all(). Если на вход поступает что либо то это обьект request
Далее сервер генерирует корректный ответ обрабатывая запрос функцией generate_response()
В зависимости от того какие в запросе приходят Method, User-Agent и Content-Type формируется ответ сервера. Если не сгенерировать корректный ответ то будет затруднена диагностика приложения, так же Aletrmanager без корректных ответов не будет присылать оповещения о завершении аварийных событий.
За формирование ответа отвечает функция generate_response(). Так же она парсит запрос и получает из нее json payload.
Из полученого от Alertmanageer json функция make_current_alarm() формирует текущий Alarm - это обьект namedtuple в
котором присутствуют:
 - имя аларма - alertname 
 - статус аларма - status (firing resolved) 
 - время возникновения события startsAt 
 - Узел на котором возникло событие - node

Если получен корректный текущий аларм - он проверется на наличие в хранилище алармов - списке all_alarms. Это сделано для того, чтобы 
присылать пользователям только уникальные события, т.к. на мой взгляд 4 позиций в Alarm достаточно чтобы однозначно определить аларм.

Если аларм отсутсвует в текущем списке алармов, что значит что он новый. Новый аларм добавляется в хранилище. 
Далее если файл с подписками перезаписывался позже даты, полученой в users_reload_time то это означает что добавился новый пользователь 
или у какого-либо пользователся изменилась подписка.
В таком случае переменной users_reload_time присваивается текущее время и список пользователей перезачитывается.
Далее всем пользователям в том случае если их подписка находится в имени аларма,
в цикле рассылаются сообщения методом bot.send_message()


## Описание класса взаимодействия с Telegram.

Конструктор класса Bot как указывалось выше описан к файле bot.py.
Класс Bot отвечает за взаимодействие с Telegram. Так же в нем прописаны функции взаимодействия с Grafana.
Взаимодействие с Grafana не является обязательным, достаточно указать "None" в любой из настроек графаны и функции взаимодействия с ней не будут включены.
Класс Bot использует модуль pyTelegramBotAPI. Он наследуется от обьекта telebot.TeleBot, для которого необходимо указать токен бота.
Так же в методе __init__ конструктор принимает конфиг в виде списка.
Так как бот работает только с помощью опроса сервера то проски является обязательным.
Так же определяется обьект dashboards - это список дашбордов графаны. Если графана не подключена то обьект будет равен None.



Далее стоит уточнить, что пользователь может отправить боту команду или сообщение. Команда это текст который начинается с форвардслеша - / . Например '/start' это команда. Если то что отправил пользователь не подходит под данное условие то это сообщение. Пример сообщения: 'test123 qwerty 42'

После того как мы уточнили эот момент рассмотрим функцию prepare_keyboard(). Она будет генерировать клавиатуру, отдаваемую ботом пользователю в процессе интерактивного общения. Клавиатура будет формироваться из двух аргументов. Первый это список lst. Второй аргумент add_slash если не указан, то пользователю будет выдан список обычных кнопок из lst, если же он будет равен True то к каждому пункту результирующей клавиатуры будет добавлен слеш / . Таким образом пользователю будет выдан список команд из lst. 

Это сделано потому что необходиом по разному обрабатывать дашборды и конкретные графики. При запроосе дашборда необходимо вернуть пользователю список всех его графиков. При запросе графика нужно отправить его скриншот.

Если и графики и дашборды подгрузить в команды то необходимо будет разрабатывать механизм того как бот будет определят что ему послали на вход. Наличие же решения с опциональным добавлением слеша в функции prepare_keyboard() позволяет обрабатывать дашборды как команды а графики как сообщения.


Функция handle_start() определяет обработку стартового сообщения от пользователя. Она обрамлена декоратором @bot.message_handler(commands=['start']) , таким образом обрабатывает команду /start.
Пользователю выводится приветственное сообщение. Предлагается добавить подписку на аларм. Если подключена графана, то выводится клавиатура с ее дашбордами. 


Функция handle_help(message) обрабатывавет команду '/help'. Выводит расширенную подсказку и краткие примеры использования.

Функция handle_regexp(message) обрабатывает команду '/regexp'. Все что пользователь ввел после пробела от команды regexp заносится в подписку пользователю.

Функция handle_list(message) обрабатывает команду '/list'. Выводит пользователю его подписку.

Функция handle_dashboards(message) обрабатывает команду содержащую в себе имя дашборда, например '/some_dashboard'

Функция handle_text(message) обрабатывает текстовые сообщения, которые присылает пользователь. Если текстовое сообщение совпадает с названием графика, то будет загружен и отправлен пользователю скриншот данного графика, отрендеренный средствами Grafana. Для загрузки используется функция download_image которая с помощью модуля requests вызывает специальный метод API графаны, который возвращает отрендеренную картинку.

Для получения информации о дашбордах и графиках графыны используются функции get_grafana_dashboards и get_grafana_panels соответственно. Функции вызывают соответствующие методы API Grafana с помощью модуля requests. 

Все функции исполььзующие взаимодействие с Grafana по HTTP при неудачных попытках будут использовать повторные попытки подключиться, настраиваемые декоратором @retry.

Архитектурные ограничения.

В первую очеред узкое место это исполььзование метода pooling и необходимости использовать прокси в условиях блокировки телеграм. Вариан когда телеграм будет сам присылать обновления от пользователей исключил бы риски блокировки прокси.

В текущей реализации используется один прокси, т.к. в ходе написания проекта оно исправно работало, но хорошим кейсом увеличения отказоустойчивости мог бы быть пул прокси, который перебирался бы при недоступности основного. Так же можно подумать о том чтобы в  онлайне подтягивать список прокси из интернета.

Хранение списка пользователей в текстовом файле. Для большее производительного решения лучше использовать БД или key-value хранилище, например redis.

Использование словаря как хранилища алармов во первых приведет к тому что при перезапуске бота информация об алармах в нем будет обнуляться, во вторых при их большом количестве будет расходоваться память сервера, поэтому в будущем целесообразно его так же вынисти в базу данных или отдельное более производительное хранилище.

