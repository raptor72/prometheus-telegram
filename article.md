# prometheus-telegram

**prometheus-telegram** - бот для расширения возможностей системы Prometheus по оповещению пользователей о наступлении аварийных событий.


## Функциональные возможности программы.

Бот выполняет две задачи:

1. Присылает оповещения об аварийных сообщениях из Prometheus пользователям в Telegram. 

2. Так как зачастую в качестве дашборда к Prometheus настраивается Grafana, 
бот дает возможность пользователю загружать скриншоты конкретных графиков из Grafana. 
Это позволяет удаленно получить визуализацию интересующих метрик.

Решение состоит из двух основных компонентов:
 - Точки входа программы - скрипа **main.py** запускающего сервер.
 - Скрипта **bot.py** в котором описан класс Bot, отвечающий главным образом за взаимодействие с Telegram.


Помимо этого в проекте присутствуют: 

 - конфигурационный файл - **exhample_config**
 - файл в котором храняться подписки пользователей на алармы - **users**
 - набор юнит-тестов **test_prometheus_telegram.py**
 - список зависимостей **requirements.txt**
 - файл для сборки докер-контейнера - **Dockerfile**



## Описание основного скрипта main.py.

В дальнейшем тексте для улучшения читаемости все исполняемые обьекты, такие как функции и классы буду выделять **жирным шрифтом**. Другие элементы кода, будь то аргументы командной строки или переменные будут выделены *курсивом*.


В основном скрипте в __main__ на входе принимаются 4 аргумента:

 - порт *'-p'* или *'--port'*. По умолчанию значение 8080
 - хост *'-H'* или *'--host'*. По умолчанию равен '127.0.0.1'
 - путь до конфигурационного файла *'-c'* или *'--config'*. Изначально равен переменной DEFAULT_CONFIG
 - путь до лог-файла *'-l'* или *'--log'*, по умолчанию отсутствует.

Из всех аргументов наиболее интересен *--config*. Его проверяет функция **check_config** и если файл будет составлен не верно, 
функция вернет False и скрипт не запустится. Об этом будет сгенерировано соответствующее аварийное сообщение.
Если с конфигом все впорядке, то он будет загружен и запустится основная функция **run**.
При запуске данная функция создает обьект хранилище для алармов *all_alarms*, определяет служебную переменную *users_reload_time*, загружает список пользователей и их подписки на алармы функцией **load_users** и инициализирует экземпляр класса **Bot**.

После этого функция связывает адрес и порт и начинает слушать буфер.
Методом **os.fork** порождается дочерний процесс, в котором запускается общение бота с Telegram посредством **bot.polling**.
Этот метод состоит в периодической отправке запросов get_updates на сервера Telegram. В случае наличия обновления, Telegram возвращает
ответ с json, который будет обрабатываться ботом.

В родительком процессе запускается чтение буфера функцией **read_all**. Если на вход поступает что-либо, то это обьект обозначается как *request*.
Далее сервер генерирует корректный ответ, обрабатывая *request* функцией **generate_response**.
В зависимости от того, какие в запросе приходят *Method*, *User-Agent* и *Content-Type* формируется ответ сервера. Если не сгенерировать корректный ответ, то будет затруднена диагностика приложения, так же Aletrmanager без корректных ответов не будет присылать оповещения о завершении аварийных событий.
За формирование ответа отвечает функция **generate_response**. Она же парсит запрос и получает из нее json payload.
Из полученого от Alertmanager json функция **make_current_alarm** формирует текущий *Alarm* - это обьект *collections.namedtuple* в
котором присутствуют:
 - *alertname* - имя аларма 
 - *status* - статус аларма (например firing или resolved) 
 - *startsAt* - время возникновения аварийного события  
 - *node* - узел на котором возникло событие 


Если получен корректный текущий аларм - он проверется на наличие в хранилище алармов - списке *all_alarms*. Это сделано для того, чтобы 
присылать пользователям только уникальные события, т.к. на мой взгляд 4 позиций в именованном кортеже *Alarm* достаточно, чтобы однозначно определить каждое аварийное сообщение.


Если аларм отсутсвует в текущем списке алармов, что говорит о том, что он новый, он добавляется в хранилище. 
Далее, если файл с подписками перезаписывался позже даты, записанной в переменной *users_reload_time*, то это означает, что добавился новый пользователь или у какого-либо пользователся изменилась подписка на оповещения.
В таком случае переменной *users_reload_time* присваивается текущее время и список пользователей заново перезачитывается функцией **load_users**.
Далее всем пользователям, в том случае если их подписка находится в имени аларма, в цикле рассылаются сообщения методом **bot.send_message**.



## Описание класса взаимодействия с Telegram.

Конструктор класса **Bot**, как указывалось выше, описан в файле **bot.py**.
Класс **Bot** отвечает за взаимодействие с Telegram. Так же в нем прописаны функции взаимодействия с Grafana.
Взаимодействие с Grafana не является обязательным, достаточно указать *"None"* в любой из настроек графаны и функции взаимодействия с ней не будут включены.
Класс **Bot** использует модуль *pyTelegramBotAPI*. Он наследуется от обьекта *telebot.TeleBot*, для которого необходимо указать токен бота.
Так же в методе __init__ конструктор принимает конфиг в виде списка.
Так как бот работает только с помощью опроса сервера, то проски является обязательным.
Так же в данном методе определяется обьект *dashboards* - это список дашбордов графаны. Если графана не подключена то обьект будет равен *None*.


Стоит уточнить, что пользователь может отправить боту команду или сообщение. Команда это текст, который начинается с форвардслеша - / . Например '/start' это команда. Если текст, отправленный пользователем не подходит под данное условие, то это сообщение. Пример сообщения: 'test123 qwerty 42'

После того, как мы уточнили эот момент рассмотрим функцию **prepare_keyboard**. Она будет генерировать клавиатуру, отдаваемую ботом пользователю в процессе интерактивного общения. Клавиатура будет формироваться из двух аргументов. Первый это список *lst*. Второй аргумент *add_slash* если не указан, то пользователю будет выдан список обычных кнопок из *lst*, если же он будет равен True то к каждой кнопке итоговой клавиатуры будет добавлен слеш / . Таким образом пользователю будет выдан список команд из *lst*. 

Это сделано потому что необходимо по разному обрабатывать дашборды и конкретные графики. При запросе дашборда необходимо вернуть пользователю список всех графиков, расположенных на данном дашборде. При запросе графика нужно отправить его скриншот.
Если и графики и дашборды подгрузить в команды, то необходимо будет разрабатывать механизм того, как бот будет определять, что ему послали на вход. Наличие же решения с опциональным добавлением слеша в функции **prepare_keyboard** позволяет обрабатывать дашборды как команды а графики как сообщения.

Функция **handle_start** определяет обработку стартового сообщения от пользователя. Она обрамлена декоратором *@bot.message_handler(commands=['start'])*, таким образом обрабатывает команду /start.
Пользователю выводится приветственное сообщение. Предлагается добавить подписку на оповещения. Если подключена графана, то выводится клавиатура с ее дашбордами.

Функция **handle_help(message)** обрабатывавет команду '/help'. Выводит расширенную подсказку и краткие примеры использования бота.

Функция **handle_regexp(message)** обрабатывает команду '/regexp'. Все что пользователь ввел после пробела от команды regexp заносится в подписку пользователю.

Функция **handle_list(message)** обрабатывает команду '/list'. Выводит пользователю его подписку.

Функция **handle_dashboards(message)** обрабатывает команду содержащую в себе имя дашборда, например '/some_dashboard'. Возвращает клавиатуру с набором кнопок в виде сообщений. В кнопках содержатся названия графиков запрошенного дашборда. 

Функция **handle_text(message)** обрабатывает сообщения, которые присылает пользователь. Если текстовое сообщение совпадает с названием графика на дашборде, который был отправлен предидущей командой, то будет загружен и отправлен пользователю скриншот данного графика, отрендеренный средствами Grafana. Для загрузки используется функция **download_image**, которая с помощью модуля requests вызывает специальный метод API графаны, который возвращает картинку.

Для получения информации о дашбордах и графиках Grafana используются функции **get_grafana_dashboards** и **get_grafana_panels** соответственно. Функции вызывают соответствующие методы API Grafana с помощью модуля *requests*. 

Все функции исполььзующие взаимодействие с Grafana по HTTP при неудачных попытках будут использовать повторные попытки подключиться, настраиваемые декоратором *@retry*, который в качестве единственного аргумента принимает количество переповторов.



## Архитектурные особенности и дальнейшие планы.

В первую очередь узкое место решения, это использование метода **bot.pooling** и необходимости использовать прокси в условиях блокировки телеграм. Вариан, когда телеграм будет сам присылать обновления от пользователей исключил бы риски блокировки прокси.

В текущей реализации используется один прокси-серер, т.к. в ходе написания проекта он исправн работал, но хорошим кейсом увеличения отказоустойчивости мог бы быть пул прокси, который перебирался бы при недоступности основного. Так же можно подумать о том, чтобы в  онлайне подтягивать список прокси из интернета.

Хранение списка пользователей в текстовом файле так же архитектурное допущение для небольшой планируемой нагрузки. Для более производительного решения лучше использовать БД или key-value хранилище, например redis.

Использование словаря как хранилища алармов во первых приводит к тому что при перезапуске бота информация об алармах в нем будет обнуляться, во вторых при их большом количестве будет расходоваться память сервера, поэтому в будущем целесообразно его так же вынести в базу данных или отдельное более производительное хранилище.

