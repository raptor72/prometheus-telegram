# prometheus-telegram

**prometheus-telegram** - бот для расширения возможностей системы Prometheus по оповещению пользователей о наступлении аварийных событий.

Бот выполняет две задачи:

1. Присылает оповещения об аварийных сообщениях из Prometheus пользователям в Telegram. 

2. Так как зачастую в качестве дашборда к Prometheus настраивается Grafana, 
бот дает возможность пользователю загружать скриншоты конкретных графиков из Grafana. 
Это позволяет удаленно получить визуализацию интересующих метрик.

Решение состоит из двух основных компонентов. 
 - Скрипта **bot.py** в котором описан класс Bot, отвечающий главным образом за взаимодействие с Telegram.
 - Точка входа программы - скрипт **main.py** запускающий сервер.

Помимо этого в проекте присутствует: 

 - конфигурационный файл - **exhample_config**
 - файл в котором храняться подписки пользователей на алармы - **users**
 - набор юнит-тестов **test_prometheus_telegram.py**
 - список зависимостей **requirements.txt**
 - файл для сборки докер-контейнера - **Dockerfile**

В main.py __main__ на входе принимаются 4 аргумента:

 - порт'-p', '--port'  по умолчанию 8080)
 - хост '-H', '--host', по умолчанию  '127.0.0.1')
 - путь до конфигурационного файла '-c', '--config', по умолчанию =DEFAULT_CONFIG)
 - путь до лог-файла '-l', '--log', по умолчанию None)

Наиболее интересен конфиг. Его проверяет функция check_config если файл будет составлен не верно 
функция вернет False и скрипт не запустится. Об этом будет сгенерировано соответствующее аварийное сообщение.
Если с конфигом все впорядке то запускается функция run.
При запуске данная функция создает обьект хранилище для алармов all_alarms, загружает конфиг-файл, создает служебную переменную users_reload_time, загружает список пользователей и их подписка на алармы функцией load_users() и инициализирует экземпляр класса Bot. 

После функция связывает адрес и порт и начинает слушать буфер.
Далее методом os.fork() порождается дочерний процесс в котором запускается метод общения бота с телеграм bot.polling()
Этот метод состоит в периодической отправке запросов get_updates на сервера телеграм. В случае наличия обновления Telegram возвращает
ответ ответ с json,  который будет обрабатываться ботом.

В родительком процессе запускается чтение буфера функцией read_all(). Если на вход поступает что либо то это обьект request
Далее сервер генерирует корректный ответ обрабатывая запрос функцией generate_response()
В зависимости от того какие в запросе приходят Method, User-Agent и Content-Type формируется ответ сервера. Если не сгенерировать корректный ответ то будет затруднена диагностика приложения, так же Aletrmanager без корректных ответов не будет присылать оповещения о завершении аварийных событий.
За формирование ответа отвечает функция generate_response(). Так же она парсит запрос и получает из нее json payload.
Из полученого от Alertmanageer json функция make_current_alarm() формирует текущий Alarm - это обьект namedtuple в
котором присутствуют:
 - имя аларма - alertname 
 - статус аларма - status (firing resolved) 
 - время возникновения события startsAt 
 - Узел на котором возникло событие - node

Если получен корректный текущий аларм - он проверется на наличие в хранилище алармов - списке all_alarms. Это сделано для того, чтобы 
присылать пользователям только уникальные события, т.к. на мой взгляд 4 позиций в Alarm достаточно чтобы однозначно определить аларм.

Если аларм отсутсвует в текущем списке алармов, что значит что он новый. Новый аларм добавляется в хранилище. 
Далее если файл с подписками перезаписывался позже даты, полученой в users_reload_time то это означает что добавился новый пользователь 
или у какого-либо пользователся изменилась подписка.
В таком случае переменной users_reload_time присваивается текущее время и список пользователей перезачитывается.
Далее всем пользователям в том случае если их подписка находится в имени аларма,
в цикле рассылаются сообщения методом bot.send_message()

Экземпляр класса Bot как указывалось выше описан к файле bot.py.
Класс Bot отвечает за взаимодействие с телеграм. Так же в нем прописаны функции взаимодействия с Grafana.
Взаимодействие с Grafana не является обязательным, достаточно указать "None" в любой из настроек графаны и функции взаимодействия с ней не будут включены.
Класс Bot использует модуль pyTelegramBotAPI. Он наследуется от обьекта telebot.TeleBot, для которого необходимо указать токен бота.
Так же в методе __init__ конструктор принимает конфиг в виде списка.
Так как бот работает только с помощью опроса сервера то проски является обязательным.
Так же определяется обьект dashboards - это список дашбордов графаны. Если графана не подключена то обьект будет равен None.

Функция handle_start() определяет обработку стартового сообщения от пользователя. Она обрамлена декоратором @bot.message_handler(commands=['start']) , таким образом сообщение которое бот будет обрабатывать это команда /start.

Далее стоит уточнить, что пользователь может отправить боту команду или сообщение. Команда это текст который начинается с форвардслеша - / . Например '/start' это команда. Сообщение же это обычный текст. 'test123' - это сообщение.

После того как мы уточнили эотт момент рассмотрим функцию prepare_keyboard(). Она будет генерировать клавиатуру, отдаваемую ботом пользователю в процессе интерактивного общения. Клавиатура будет формироваться из двух аргументов. Первый lst это список. Второй аргумент add_slash если не указан, то пользователю будет выдан список обычных кнопок из lst, если же он будет равен True то к каждому пункту результирующей клавиатуры будет добавлен слеш / . Таким образом пользователю будет выдан список команд из lst. 

Это сделано для того чтобы по разному обрабатывать дашборды и конкретные графики. 

Если и графики и дашборды подгрузить в команды то необходимо будет разрабатывать механизм того как бот будет различать 
что ему послали команду на график или на дашборд.








